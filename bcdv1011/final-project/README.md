# CryptoLoan

This is done as a final project for the course BCDV1011 at George Brown College.
I've used Embark framework for testing smart contracts using their underlying implementation of Mocha, which is a JavaScript test framework.

I've used Verifier Pattern for restricting functions in particular, Modularity Pattern for implementing SafeMath library and identity pattern where identity to me as a contract owner is the single unique identifier of the people I've lent my money to. This way, using design patters have enhanced the code readability and implementation to be very clean and comprehensive.

I've tried developing this project using the Test Driven Development style.

There is one contract with 3 methods, 1 library and 1 modifier in it viz.,
```Solidity
library SafeMath {} //from OpenZeppelin
function addLoan (address _payee, uint principle, uint rate, uint time) public onlyOwner{}
function viewLoan (address _payee) public view returns(uint) {}
function editLoan (address _payee, uint amount) public onlyOwner {}
```
___

For the questions asked in the assignment, stated below are the questions and their answers.

> Explains in details two enterprise patterns of your choice. What are the business problems theyâ€™re trying to solve? What are the most commonly used solutions? What may be some limitations of the current state of the art with this technology?

Answer:
+ Factory Pattern 

   **Explanation**: Smart contracts are created from a contract factory deployed on blockchain. The factory contract is deployed once from the off-chain source code. The factory may contain the defnition of multiple smart contracts. Smart contract instances are generated by passing parameters to the contract factory to instantiate customized smart contract instances. 
   **Business Problem**: In a business process management system, each of the business process instances might be represented by a smart contract being generated from a contract template representing the business process model. Keeping the contract template off-chain cannot guarantee consistency between different smart contract instances created from the same template because the source code of the template can be independently modified.
   **Commonly used solutions**: Commonly developers make new contracts for every situation. Factory pattern is well illustrated on Ethereum Developers using a simple [Hello World example](https://ethereumdev.io/manage-several-contracts-with-factories/)
   **Limitations**: Deployment cost.

+ Reverse Verifier

   **Explanation**: The reverse verifer of an existing system relies on smart contracts running on blockchain to validate requested data and check required status. ID of the transactions or blocks on blockchain is a piece of data that can be easily integrated into the existing systems. Validation of the data can be implemented by smart contracts running on blockchain. 
   **Business Problem**: When non-intrusive approach is desired to leverage the existing complex systems with blockchain without changing the core of the existing systems.
   **Usage**: By Slock.it.
   **Limitation**: Non-intrusive.

___

> Submitted By: Shailendra Shukla (101224373)
